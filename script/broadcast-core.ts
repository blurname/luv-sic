import { existsSync, mkdirSync, watch, writeFileSync, readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';

// é…ç½®
const CORE_DIR = join(process.cwd(), 'pkg/core/src');
const ENTRIES = ['common.ts', 'node.ts', 'browser.ts'];
const CLIENTS_CONFIG = join(process.cwd(), 'core-clients.json');

const HEADER = `// [AUTOGENERATED] DO NOT EDIT! THIS FILE IS A CONCATENATED COPY.
// Original source: luv-sic/pkg/core/src
// To modify, edit the modular source files in luv-sic and run 'bun broadcast-core'\n\n`;

async function getClients() {
  if (!existsSync(CLIENTS_CONFIG)) return [];
  try {
    const content = await Bun.file(CLIENTS_CONFIG).text();
    return JSON.parse(content);
  } catch (e) {
    console.error('âŒ è§£æ core-clients.json å¤±è´¥:', e);
    return [];
  }
}

/**
 * æç®€çš„ TS åˆå¹¶é€»è¾‘ï¼šå°† export * from './xxx' æ›¿æ¢ä¸ºæ–‡ä»¶å®é™…å†…å®¹
 */
function flattenTS(entryPath: string): string {
  const content = readFileSync(entryPath, 'utf-8');
  const lines = content.split('\n');
  const baseDir = dirname(entryPath);
  let flattened = '';

  for (const line of lines) {
    const match = line.match(/export \* from ['"]\.\/(.*)['"]/);
    if (match) {
      const subFilePath = join(baseDir, match[1].endsWith('.ts') ? match[1] : `${match[1]}.ts`);
      if (existsSync(subFilePath)) {
        flattened += `\n// --- Inlined from ${match[1]} ---\n`;
        // é€’å½’å¤„ç†ï¼ˆå¦‚æœè¿˜æœ‰åµŒå¥—å¯¼å‡ºï¼‰æˆ–ç›´æ¥è¯»å–å†…å®¹å¹¶å»æ‰å¯èƒ½å†²çªçš„ import
        let subContent = readFileSync(subFilePath, 'utf-8');
        // ç®€å•å¤„ç†ï¼šå»æ‰å­æ–‡ä»¶ä¸­çš„ç›¸å¯¹å¯¼å…¥ï¼ˆå› ä¸ºéƒ½è¢«åˆå¹¶åˆ°ä¸€å±‚äº†ï¼‰
        subContent = subContent.replace(/^import .* from ['"]\.\.?\/.*['"]/gm, (m) => `// ${m} (commented out by bundler)`);
        flattened += subContent + '\n';
      }
    } else if (line.trim().startsWith('import')) {
      // ä¿æŒå¤–éƒ¨å¯¼å…¥ï¼ˆå¦‚ node:fsï¼‰
      flattened += line + '\n';
    } else {
      flattened += line + '\n';
    }
  }
  return flattened;
}

async function bundleAndSync() {
  const clients = await getClients();
  console.log(`\nğŸ“„ [${new Date().toLocaleTimeString()}] æ­£åœ¨åˆå¹¶å¹¶åˆ†å‘æ ¸å¿ƒåŒ… (TS Mode)...`);

  const bundled = new Map<string, string>();
  for (const entry of ENTRIES) {
    const entryPath = join(CORE_DIR, entry);
    if (existsSync(entryPath)) {
      bundled.set(entry, flattenTS(entryPath));
    }
  }

  for (const clientPath of clients) {
    const absoluteClientPath = join(process.cwd(), clientPath);
    if (existsSync(absoluteClientPath)) {
      const dest = join(absoluteClientPath, 'src/@core');
      if (!existsSync(dest)) mkdirSync(dest, { recursive: true });

      for (const [fileName, content] of bundled) {
        writeFileSync(join(dest, fileName), HEADER + content);
      }
      console.log(`âœ… å·²åŒæ­¥ TS æºç è‡³: ${clientPath}/src/@core`);
    }
  }
}

await bundleAndSync();

if (process.argv.includes('--watch')) {
  console.log('\nğŸ‘€ æ­£åœ¨ç›‘å¬ core/src å˜åŒ– (TS Flat Mode)...');
  watch(CORE_DIR, { recursive: true }, async (event, filename) => {
    if (filename && !ENTRIES.includes(filename)) {
       console.log(`ğŸ“ æ¨¡å—å˜æ›´: ${filename}`);
       await bundleAndSync();
    }
  });
}
