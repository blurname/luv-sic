import { cpSync, existsSync, mkdirSync, watch, readdirSync, statSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';

// é…ç½®
const CORE_SRC = join(process.cwd(), 'pkg/core/src');
const CLIENTS_CONFIG = join(process.cwd(), 'core-clients.json');
const HEADER = `// [AUTOGENERATED] DO NOT EDIT! THIS FILE IS A COPY.
// Original source: luv-sic/pkg/core/src
// To modify, edit the source file and run 'bun broadcast-core'\n\n`;

async function getClients() {
  if (!existsSync(CLIENTS_CONFIG)) return [];
  try {
    const content = await Bun.file(CLIENTS_CONFIG).text();
    return JSON.parse(content);
  } catch (e) {
    console.error('âŒ è§£æž core-clients.json å¤±è´¥:', e);
    return [];
  }
}

function syncWithHeader(srcDir: string, destDir: string, header: string) {
  const items = readdirSync(srcDir);
  for (const item of items) {
    const srcPath = join(srcDir, item);
    const destPath = join(destDir, item);
    const stats = statSync(srcPath);

    if (stats.isDirectory()) {
      if (!existsSync(destPath)) mkdirSync(destPath, { recursive: true });
      syncWithHeader(srcPath, destPath, header);
    } else if (stats.isFile() && (item.endsWith('.ts') || item.endsWith('.js') || item.endsWith('.tsx'))) {
      const content = readFileSync(srcPath, 'utf-8');
      writeFileSync(destPath, header + content);
    } else {
      // éžä»£ç æ–‡ä»¶ç›´æŽ¥æ‹·è´
      cpSync(srcPath, destPath);
    }
  }
}

async function syncToAll() {
  const clients = await getClients();
  console.log(`\nðŸ”„ [${new Date().toLocaleTimeString()}] å¼€å§‹å…¨é‡åŒæ­¥ core...`);
  
  for (const clientPath of clients) {
    const absoluteClientPath = join(process.cwd(), clientPath);
    if (existsSync(absoluteClientPath)) {
      const dest = join(absoluteClientPath, 'src/@core');
      if (!existsSync(dest)) mkdirSync(dest, { recursive: true });
      
      syncWithHeader(CORE_SRC, dest, HEADER);
      console.log(`âœ… å·²åŒæ­¥è‡³: ${clientPath}/src/@core`);
    } else {
      console.warn(`âš ï¸ è·³è¿‡ä¸å­˜åœ¨çš„é¡¹ç›®: ${clientPath}`);
    }
  }
}

// 1. å¯åŠ¨æ—¶å…ˆåŒæ­¥ä¸€æ¬¡
await syncToAll();

// 2. ç›‘å¬æ¨¡å¼
if (process.argv.includes('--watch')) {
  console.log('\nðŸ‘€ æ­£åœ¨ç›‘å¬ core/src å˜åŒ–...');
  
  const watcher = watch(CORE_SRC, { recursive: true }, async (event, filename) => {
    if (filename) {
      console.log(`ðŸ“ æ£€æµ‹åˆ°å˜åŒ–: ${filename}`);
      await syncToAll();
    }
  });

  process.on('SIGINT', () => {
    watcher.close();
    process.exit();
  });
}
